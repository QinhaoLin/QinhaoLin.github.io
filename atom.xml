<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-29T06:29:00.919Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git入门</title>
    <link href="http://yoursite.com/2019/01/29/Git%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/01/29/Git入门/</id>
    <published>2019-01-29T13:21:02.000Z</published>
    <updated>2019-01-29T06:29:00.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h1><h3 id="下载window-git"><a href="#下载window-git" class="headerlink" title="下载window git"></a>下载window git</h3><blockquote><p><strong>Msysgi</strong>    <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a>  </p></blockquote><h3 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h3><ol><li><h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><p>打开 Git Bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># global 意思是本机所以仓库都使用此配置，也可以单独对某个仓库进行配置</span><br><span class="line">git config --global user.name &quot;xxx&quot;</span><br><span class="line">git config --global user.email &quot;xxx@163.com&quot;</span><br><span class="line"># 查看是否配置成功</span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure></li><li><h4 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h4><p>下载安装 Sourcetree</p><blockquote><p><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">https://www.sourcetreeapp.com/</a></p></blockquote></li></ol><h1 id="Git仓库"><a href="#Git仓库" class="headerlink" title="Git仓库"></a>Git仓库</h1><ul><li><p>初始化版本库  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在需要创建为git仓库的文件夹中输入，会在当前文件夹中生成.git文件夹</span><br><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p>添加文件到版本库  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># git add 文件名 </span><br><span class="line">git add</span><br><span class="line"># git commit -m &quot;输入提交的描述信息&quot;</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure></li><li><p>查看仓库状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li></ul><h1 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h1><ul><li>==工作区==</li><li>版本库<ul><li>==暂存区（index）== </li><li>==Head（master）==</li><li>objects 文件存储区</li></ul></li></ul><p>工作区提交到暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># git add 文件名 将文件提交到暂存区</span><br></pre></td></tr></table></figure></p><p>暂存区回滚到工作区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># git reset HEAD 文件名</span><br><span class="line">git reset HEAD </span><br><span class="line"># git checkout -- 文件名</span><br><span class="line">git checkout</span><br></pre></td></tr></table></figure><p>暂存区的文件提交到Head</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># git commit -m &quot;输入提交的描述信息&quot;  </span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>Head回滚到工作区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看提交历史记录，获取commit对应的key</span><br><span class="line">git log</span><br><span class="line"># 将暂存区和最终本地仓库的文件都回滚到某次版本提交</span><br><span class="line"># git reset --hard commit对应的key</span><br><span class="line">git reset --hard</span><br></pre></td></tr></table></figure></p><p>删除本地的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># git rm 文件名</span><br><span class="line">git rm</span><br><span class="line"># 暂存区和仓库也要提交删除，需要commit</span><br><span class="line">git commit -m &quot;&quot;</span><br></pre></td></tr></table></figure></p><h1 id="Github远程仓库"><a href="#Github远程仓库" class="headerlink" title="Github远程仓库"></a>Github远程仓库</h1><h3 id="创建SSH-key"><a href="#创建SSH-key" class="headerlink" title="创建SSH key"></a>创建SSH key</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1.创建ssh Key，邮箱地址需要是github上注册的邮箱</span><br><span class="line"># 2.在用户目录下会生成id_rsa（私匙），id_rsa.pub（公钥）</span><br><span class="line"># 3.将id_rsa.pub（公钥）拷贝到github，Settings-&gt;SSH and GPG keys-&gt;New SSH key</span><br><span class="line">ssh-keygen -t rsa -C &quot;xxx@163.com&quot;</span><br><span class="line"># 查看是否能连接到github</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 1.在github上创建仓库New repository-&gt;hello_github</span><br><span class="line"># 2.1 在本地创建仓库hello_github</span><br><span class="line"># 2.2 echo &quot;# 项目名&quot; &gt;&gt; README.md</span><br><span class="line">echo &quot;# hello_github&quot; &gt;&gt; README.md</span><br><span class="line"># 2.3 git init </span><br><span class="line"># 2.4 git add README.md </span><br><span class="line"># 2.5 git commit -m &quot;first commit&quot; </span><br><span class="line"># 3.将本地仓库与远程仓库关联起来</span><br><span class="line">git remote add origin git@github.com:QinhaoLin/hello_github.git</span><br><span class="line"># 4.推送到远程仓库 -u 默认将本地master与远程master关联起来，之后可以直接 git push</span><br><span class="line">git push -u origin master</span><br><span class="line"># 取回远程主机master的更新，再与本地master合并</span><br><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><p>将远程仓库代码克隆到本地仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在初始化本地仓库，输入git clone git@github项目地址</span><br><span class="line">git clone git@github.com:QinhaoLin/hello_github.git</span><br><span class="line"># 提交到本地master后，可以直接git push，不用-u指定远程仓库master</span><br></pre></td></tr></table></figure><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有标签</span><br><span class="line">git tag</span><br><span class="line"># 创建标签</span><br><span class="line">git tag name</span><br><span class="line"># 标签发布</span><br><span class="line">git push origin name</span><br><span class="line"># 指定提交信息</span><br><span class="line">git tag -a name -m &quot;comment&quot; </span><br><span class="line"># 删除标签</span><br><span class="line">git tag -d name</span><br></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 新建分支，git branch 分支名</span><br><span class="line">git branch feature_x</span><br><span class="line"># 查看当前所有分支，* 代表当前在哪个分支上</span><br><span class="line">git branch</span><br><span class="line"># 切换分支，git checkout 分支名</span><br><span class="line">git checkout feature_x</span><br><span class="line"># 合并分支到master中</span><br><span class="line"># 切换到master分支，git merge 分支名 </span><br><span class="line">git merge feature_x </span><br><span class="line"># 删除分支 git branch -d 分支名</span><br><span class="line">git branch -d feature_x</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>工作流：工作区 -&gt; 暂存区 -&gt; 版本库<br>初始化：git init -&gt; git add -&gt; git commit<br>远程仓库：git remote add -&gt; git pull -&gt; git push -&gt; git clone<br>分支管理：git branch -&gt; git checkout -&gt; git merge<br>标签管理：git tag -&gt; git push</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git安装&quot;&gt;&lt;a href=&quot;#Git安装&quot; class=&quot;headerlink&quot; title=&quot;Git安装&quot;&gt;&lt;/a&gt;Git安装&lt;/h1&gt;&lt;h3 id=&quot;下载window-git&quot;&gt;&lt;a href=&quot;#下载window-git&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据结构和算法-绪论</title>
    <link href="http://yoursite.com/2018/12/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E7%BB%AA%E8%AE%BA/"/>
    <id>http://yoursite.com/2018/12/28/数据结构和算法-绪论/</id>
    <published>2018-12-28T05:37:52.000Z</published>
    <updated>2018-12-28T05:50:06.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="数据结构和算法绪论"><a href="#数据结构和算法绪论" class="headerlink" title="数据结构和算法绪论"></a>数据结构和算法绪论</h2><h4 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h4><blockquote><p>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。  </p><ul><li>程序设计=数据结构+算法</li><li>再简单的来说数据结构就是关系，就是数据元素相互之间存在的一种或多种特定关系的集合。</li></ul></blockquote><h4 id="逻辑结构和物理结构"><a href="#逻辑结构和物理结构" class="headerlink" title="逻辑结构和物理结构"></a>逻辑结构和物理结构</h4><blockquote><ul><li>传统上，我们把数据结构分为逻辑结构和物理结构。</li><li>逻辑结构：是指数据对象中数据元素之间的相互关系。</li><li>物理结构：是指数据的逻辑结构在计算机中的存储形式。</li></ul></blockquote><h4 id="四大逻辑结构"><a href="#四大逻辑结构" class="headerlink" title="四大逻辑结构"></a>四大逻辑结构</h4><blockquote><ul><li>集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他任何关系。</li><li>线性结构：线性结构中的数据元素之间是一对一的关系。</li><li>树形结构：树形结构中的数据元素之间存在一种一对多的层次关系（像3P，4P等）</li><li>图形结构：图形结构的数据元素是多对多的关系。</li></ul></blockquote><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><blockquote><ul><li>根据物理结构的定义，我们实际上研究的就是如何把数据元素存储到计算机的存储器中。</li><li>存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。</li><li>数据元素的存储结构形式有两种：顺序存储和链式存储。</li><li>顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。（例如：数组结构）</li><li>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。<br>链式存储结构的数据元素存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样子通过地址就可以找到相关数据元素的位置。</li></ul></blockquote><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h4 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h4><blockquote><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p></blockquote><h4 id="算法的特征"><a href="#算法的特征" class="headerlink" title="算法的特征"></a>算法的特征</h4><blockquote><p>算法具有五个基本特征：输入、输出、有穷性、确定性和可行性。</p><ul><li>输入<br>算法具有零个或多个输入。<br>尽管对于绝大多数算法来说，输入参数都是必要的，但是有些时候，也可以不输入。</li><li>输出<br>算法至少有一个或多个输出。<br>算法是一定要输出的，输出的形式可以是打印形式输出，也可以是返回一个值或多个值等。</li><li>有穷性<br>指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。</li><li>确定性<br>算法的每一个步骤都具有确定的含义，不会出现二义性。<br>算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。<br>算法的每个步骤都应该被精确定义而无歧义。</li><li>可行性<br>算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。</li></ul></blockquote><h4 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h4><blockquote><p>算法不是唯一的，也就是说同一个问题，可以有多种解决问题的算法。</p><ul><li>正确性<br>算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能够正确反映问题的需求、能够得到问题的正确答案。<br>大致分为以下四个层次：<br>算法程序没有语法错误。<br>算法程序对于合法输入能够产生满足要求的输出。<br>算法程序对于非法输入能够产生满足规格的说明。<br>算法程序对于故意刁难的测试输入都有满足要求的输出结果。</li><li>可读性<br>算法设计的另一个目的是为了便于阅读、理解和交流。<br>写代码的目的，一方面是为了计算机执行，但还有一个重要的目的是为了便于他人阅读和自己日后阅读修改。</li><li>健壮性<br>当输入数据不合法时，算法也能做出相关处理，而不是产生异常、崩溃或莫名奇妙的结果。  </li><li>时间效率高和存储量低<br>好算法，应该具备时间效率高和存储量低的特点。所以在设计算法的时候我们应该尽量思考这两方面的问题！</li></ul></blockquote><h2 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h2><h4 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h4><blockquote><ul><li>事后统计方法<br>这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。<br>这种方法显然是有很大缺陷的：<br>必须依据算法事先编制好测试的程序，通常需要花费大量的时间和精力。<br>不同的测试环境也有很大的差别。  </li><li>事前分析估算方法<br>在计算机程序编写前，依据统计方法对算法进行估算。  </li><li>高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素<br>1.算法采用的策略，方案<br>2.编译产生的代码质量<br>3.问题的输入规模<br>4.机器执行指令的速度  </li><li>由此可见，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间依赖于算法的好坏和问题的输入规模。（所谓的问题输入规模是指输入量的多少）</li><li>如果非常较真的研究总共精确执行次数，那是非常累的。我们研究算法的复杂度，侧重的是研究算法随着输入规模扩大增长量的一个抽象，而不是精确地定位需要执行多少次，因为如果这样的话，我们就又得考虑回编译器优化等问题，然后，然后就永远也没有然后了！  </li><li>我们不关心编写程序所用的语言是什么，也不关心这些程序将跑在什么样的计算机上，我们只关心它所实现的算法。 </li><li>这样，不计那些循环索引的递增和循环终止条件、变量声明、打印结果等操作。最终，在分析程序的运行时间，最重要的是把程序看成是独立于程序设计语言的算法或一系列操作。</li><li>我们在分析一个算法的运行时间时，重要的是把基本操作的数量和输入模式关联起来。</li></ul></blockquote><h4 id="函数渐进增长"><a href="#函数渐进增长" class="headerlink" title="函数渐进增长"></a>函数渐进增长</h4><blockquote><ul><li>函数的渐进增长：<br>给定2个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐进快于g(n)。  </li><li>最高次项的指数大的，函数随着n的增长，结果也会变得增长特别快。</li><li>算法G是2n^2 ，算法H是3n+1，算法I是2n^2+3n+1<br>当n的值变得非常大的时候，3n+1已经没法和2n^2的结果相比较，最终几乎可以忽略不计。而算法G跟算法I基本重合了。<br>于是我们可以得到这样的一个结论，判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高项）的阶数。<br>注意，判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的的，很容易以偏概全。</li></ul></blockquote><h4 id="算法时间复杂度的定义"><a href="#算法时间复杂度的定义" class="headerlink" title="算法时间复杂度的定义"></a>算法时间复杂度的定义</h4><blockquote><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。（执行次数==时间）<br>这样用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。<br>一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。<br>显然，由此算法时间复杂度的定义可知，我们的三个求和算法的时间复杂度分别为O(1)，O(n)，O(n^2)。  </p></blockquote><h4 id="推到大O阶方法"><a href="#推到大O阶方法" class="headerlink" title="推到大O阶方法"></a>推到大O阶方法</h4><blockquote><ul><li>用常数1取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留最高项阶。</li><li>如果最高项存在且不是1，则去除与这个最高项相乘的常数。</li><li>得到的最后结果就是大O阶。</li></ul></blockquote><h5 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0, n = 100;</span><br><span class="line">System.out.println(&quot;Hello&quot;);</span><br><span class="line">System.out.println(&quot;Hello&quot;);</span><br><span class="line">System.out.println(&quot;Hello&quot;);</span><br><span class="line">System.out.println(&quot;Hello&quot;);</span><br><span class="line">System.out.println(&quot;Hello&quot;);</span><br><span class="line">System.out.println(&quot;Hello&quot;);</span><br><span class="line">sum = (1+n)*n/2</span><br></pre></td></tr></table></figure><blockquote><p>不能从汇编的角度分析，应该以高级语言的角度分析。<br>这段代码的大O是多少？<br>O(8)？<br>总认为有多少条语句就有多少。<br>分析下，按照我们的概念“T(n)是关于问题规模n的函数”来说，这里，跟问题规模没有关系，所以我们记作O(1)就可以。<br>另外，如果按照攻略来，那就更简单了，攻略第一条就说明了所有加法常数给他个O(1)即可。 </p></blockquote><h5 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h5><blockquote><p>一般含有非嵌套循环涉及线性阶，线性阶就是随着问题规模n的扩大，对应计算次数呈直线增长。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i, n = 100, sum = 0;</span><br><span class="line">for(i=0; i&lt;n; i++) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面这段代码，它的循环的时间复杂度为O(n)，因为循环体中的代码需要执行n次。</p></blockquote><h5 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i, j, n = 100;</span><br><span class="line">for(i=0; i&lt;n; i++) &#123;</span><br><span class="line">int i, n = 100, sum = 0;</span><br><span class="line">    for(j=0; j&lt;n; j++) &#123;</span><br><span class="line">    System.out.println(&quot;Hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>n等于100，也就是说外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环出来，需要执行100*100次，也就是n的平方。所以这段代码的时间复杂度为O(n^2)。<br>那如果有三个这样的嵌套循环，那就是n^3。所以我们很容易总结得出，循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i, j, n = 100;</span><br><span class="line">for(i=0; i&lt;n; i++) &#123;</span><br><span class="line">int i, n = 100, sum = 0;</span><br><span class="line">    for(j=i; j&lt;n; j++) &#123;</span><br><span class="line">    System.out.println(&quot;Hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析下，由于当i等于0时，内循环执行了n次，当i=1时，内循环则执行n-1次……当i=n-1时，内循环就执行了1次，所以总共的执行次数应该是：<br>n+(n-1)+(n-2)+…+1 = n(n+1)/2 = n^2/2+n/2<br>用我们的推导大O的攻略，第一条忽略，因为没有常数相加。第二条只保留最高项，所以n/2这项去掉。第三条，去除与最高项相乘的常数，最终得O(n^2)。</p></blockquote><h5 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1, n = 100;</span><br><span class="line">while (i &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">    i = i * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于每次i+2之后，就距离n更近一步，假设有x个2相乘后大于或等于n，则会退出循环。<br>由于2^x = n得到x = log(2)n，所以这个循环的时间复杂度为O(logn)。</p></blockquote><h4 id="函数调用的时间复杂度分析"><a href="#函数调用的时间复杂度分析" class="headerlink" title="函数调用的时间复杂度分析"></a>函数调用的时间复杂度分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i, j;</span><br><span class="line">for(i=0; i&lt;n; i++) &#123;</span><br><span class="line">    function(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void function(int count)&#123;</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>funciton函数的时间复杂度是O(1)，所以整体的时间复杂度就是循环的次数O(n)。<br>假如fuction是下面这样</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void function(int count)&#123;</span><br><span class="line">    int j;</span><br><span class="line">    for(j=count; j&lt;n; j++) &#123;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>事实上，这和之前平方阶的时候举得第二个例子是一样的：funciton内部的循环次数随count的增长（接近n）而减少，所以根据策略，算法的时间复杂度为O(n^2)。</p></blockquote><h4 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h4><table><thead><tr><th>例子</th><th>时间复杂度</th><th>术语</th></tr></thead><tbody><tr><td>5201314</td><td>O(1)</td><td>常数阶</td></tr><tr><td>3n+4</td><td>O(n)</td><td>线性阶</td></tr><tr><td>3n^2+4n+5</td><td>O(n^2)</td><td>平方阶</td></tr><tr><td>3log(2)n+4</td><td>O(logn)</td><td>对数阶</td></tr><tr><td>2n+3nlog(2)n+14</td><td>O(nlogn)</td><td>nlogn阶</td></tr><tr><td>n^3+2n^2+4n+6</td><td>O(n^3)</td><td>立方阶</td></tr><tr><td>2^n</td><td>O(2^n)</td><td>指数阶</td></tr></tbody></table><blockquote><p>常用的时间复杂度所耗费的时间从小到大依次是：<br>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^ 2)&lt;O(n^ 3)&lt;O(2^n)&lt;O(n !)&lt;O(n^n)</p></blockquote><h4 id="最坏情况和平均情况"><a href="#最坏情况和平均情况" class="headerlink" title="最坏情况和平均情况"></a>最坏情况和平均情况</h4><blockquote><p>一般人常出于一种对未来失败的担忧，而在预期的时候趋向做最坏的打算。这样，即使最糟糕的结果出现，当事人也有了心理准备，比较容易接受结果，假如结局并未出现最坏的状况，这也会使人更加快乐，瞧，事情发展的还不错嘛！<br>算法的分析也是类似，我们查找一个有n个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1)，但也有可能这个数字就在最后一个位置，那么时间复杂度为O(n)。<br>平均运行时间是期望的运行时间。<br>最坏运行时间是一种保证。在应用中，这是一种最重要的需求，通常除非特别指定，我们提到的运行时间都是最坏情况的运行时间。</p></blockquote><h4 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h4><blockquote><p>我们在写代码时，完全可以用空间来换取时间<br>举个例子，要判断某年是不是闰年，可能会写一个算法，每给一个年份，就可以通过这个算法计算得到是否闰年的结果。<br>另一种方法是，事先建立一个有2050个元素的数组，然后把所有的年份按下标的数字对应，如果是闰年，则此数组元素的值是1，如果不是元素的值则为0，这样，所谓的判断某一年是否为闰年就变成了查找这个数组某一个元素的值的问题。<br>第一种方法相比起第二种来说很明显非常节省空间，但每一次查询都需要经过一系列的计算才能值的是否为闰年。第二种方法虽然需要在内存里存储2050个元素的数组，但是每次查询只需要一次索引判断即可。  </p></blockquote><blockquote><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。<br>通常，我们都是用“时间复杂度”来指运行时间的需求，“空间复杂度”指空间需求。<br>当直接要让我们求“复杂度”时，通常指的是时间复杂度。<br>显然对时间复杂度的追求更是属于算法的潮流！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h1&gt;&lt;h2 id=&quot;数据结构和算法绪论&quot;&gt;&lt;a href=&quot;#数据结构和算法绪论&quot; class=&quot;headerlink&quot; title=&quot;数据结构和算法
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/12/17/hello-world/"/>
    <id>http://yoursite.com/2018/12/17/hello-world/</id>
    <published>2018-12-17T02:50:57.860Z</published>
    <updated>2018-12-17T02:50:57.861Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
